The 4 component files collectively make up the component.
The file ending in spec.ts is for testing.

In the component html template file there is a span with {{ title }},
It is outputing the value that is assigned to a variable called title.
The title is defined in the app.component.ts file.

The @Component in the component.ts file is a decorator. It gives
us some information about the particular component. So this decorator
tells Agnular how this component is going to be used with selector.

In the index.html file line 11 there is a <app-root> element which
is the name of the selector which was defined in the AppComponent.

There are no hard rules for structuring our projects.

In the app.component.ts file the class is exported and in the
app.config.ts file the class and other things are imported.

Whenever we create our wishItem class, we need to export it, and
we'll call this class wishItem

We want the properties of the constructor to be accessible elsewhere
so the first thing that we do is make it public

In TS, we specify the type after we define the variable.

Regarding the two properties, whenever we define a wish item, we
pass the wishtext and denote whether or not it is completed.

After defining the wishItem class, we import it in the 
app.component.ts file and in the export class section we add an 
items array and pre-populate it with the constructor.

One benefit of TypeScript is that it provides information about
types and arguments and provides suggestions for you.

Material is Google's UI framework. But for the moment, we're going
to use Bootstrap instead of material which works fine. To use Bootstrap
in our project, we include it via cdn in our index.html file's head section.

JavaScript has a bunch of loops but the one that we typically use
is the for loop. And Angular gives us an easy way of using the for
of loop and we will use what's called a directive.

To use a directive, in the div element we use an asteriskng (*ng)
and it gives us some suggestions, the ones with the yellow icon 
are the ones that we work with (ngFor, ngIf, etc.).

The *ngFor directive is a structural directive because it changes the
structure of the DOM.

We can use the *ngIf directive to control the DOM, if the condition
we provide is true, then the element is going to be added to the document
and the content in the element will be rendered and visible. However, if
the condition is false, the element won't be rendered. We use this code:
<div *ngIf="items.length === 0">
    There are no wishes to display.
</div>

When there are no items to display and the array isn't rendered, the ul
element can be found in dev tools, to make that disappear we can type a 
ngIf condition in the ul element and say if the length of the array is
greater than 0, it is displayed.

The other approach for determining whether it is displayed or not is to
use this code instead: 
<div ngIf="items.length === 0, then noItems else showItems"></div>
<ng-template #noItems>
    There are no wishes to display.
</ng-template>
<ng-template #showItems>
    There are no wishes to display.
</ng-template>

*ngIf is also a structural directive because it changes the structure
of the document based upon the condition that is evaluated.

You cannot have two structural directives on the same element.

The way we work with data is that sometimes we want to display it and
sometimes we just want to work with it behind the scenes.

In our wish list application, we have two pieces of information that we
want to display. We want the text of the wish, we also want to show whether
or not that wish has been fulfilled.

In html, we add the checked attribute to the checkbox element to make it
be displayed as checked. 
Also on the JS side of things, this input element has a checked property.
That property is boolean. However, one thing to note is that if the html 
attribute is present, it is checked, regardless of its value. But the JS
property can be true or false which determines whether its checked or not.

To establish a connection between the isComplete property and the checked
attribute we should use property binding. We take the html attribute in 
this case checked and we sorround it with square brackets and the value 
that we assign to this is a JS expression that will determine whether or
not this check box is checked, that is the isComplete property.

When we want to bind something to the JS property of an object, we must
surround that property name with square brackets, assign the JS expression
that will then be bound to that property.

We can also bind to html attrtibutes. Let's say we wanted a custom attribute
called data-index; which would represent the index of the item in the 
array. We can get the index with the ng4 directive. To tdo this we surround
the attribute with square brackets and add attr. before the name of the 
attribute 

So we can bind data to an element's attribute or to its property.

Events are the most important part of an app with a GUI, because it is 
the primary way that the users interact with our app. 

The way we binded the checkbox with our js property was a one-way binding,
We are taking the value of isComplete and binding that to the checked 
property of the checkbox. So when the user clicks on the checkbox, it is
not updating the isComplete property. We need to write the code for that.

In order to bind an event it's going to be like the DOM level 0 event
handlers. If we wanted to handle the click event on an element, we would
use onclick. 

In Angular, we bind events like they way we bind properties and attributes.
Except instead of using brackets we use parentheses. The compiler is going
to suggest possible events that we can use and the names of them are just
plain events, they don't have the on prefix or stuff like that.

After naming the event in parentheses, we assign the JS code that is
going to execute which can be a function or an expression.

When it comes to DOM events, one of the things we typically do is 
access the event object that occurs because that gives us a lot of 
information about the event. What we have to do to get the information
is pass the event object. We do so by typing a $event in parentheses.

At first we passed $event (information about user when event occured)
to the toggleItem function to print it on the console, vut all we really
need is the item we work with, so we pass the item in the html.component.

After we edit the function to display the item in the console, we see the
information about the wish item such as wishText and isComplete, we can 
see that when the user clicks on the checkbox when if they click multiple
times, the isComplete value doesn't change so we have to update it manually.

To manually update the value of isComplete, we write a single line of 
code that toggles its value, so whenever it's clicked, the value changes
from true to false or vice-versa.

Forms, or working with forms are also one of the most important parts of'
the GUI. Events allow the users to interact with our application and forms
allow them to provide data to our application to work with.

Angular allows us to work with forms in two way, the first is called 
reactive forms which is more robust and scalable. For right now, we will
go with the second approach which is called template-driven forms. It 
allows us to define our forms inside of the template and we just reply
upon directives. 

We have added some code with Bootstrap in the component html file to create
a form for adding a wish. (The user just provide the wish text)

The first thing we want to do about this form is to handle the click (event).
We also have to prevent the form from being submitted, because that is the
default behavior of clicking a button inside of a form. To do this we use
preventDefault() with $event object to get access to it.

We can execute multiple statements on an event (click in this case) so we
first prevent the default behavior and then call a function for adding the
wish which we are going to declare in the component.

We need to find a way to bind data to this inpurt element. We do that with
syntax that essentially combines both the property binding syntax and the 
event binding syntax.
Now we need to tell Angular that we have this form field that we want to
bind to a property on our class, and we call it newWishText. Now we go
and define this property inside of our component class.

Even when we define newWishText in the ts component, we get and error:
"Can't bind to 'ngModel' since it isn't a known property of 'input'."
Now we have to open the app.module file which declares anything that
our application requires in order to run. 

In the NgModule decorator, declarations is a set of components or 
directives that belong to this particular module. AppComponent belongs 
this module because it has been declared here.

The imports are things that are available to the templates, inside of
this module. The providers are objects that can be injected to parts of
this module. The [AppComponent] is the entry point to this module.

What we need to do to be able to use the NgModel directive, is import the
FormsModule, and vscode suggests the code we need for that. In order to 
import, we have to import it on top of the file, and also in the import
section of the decorator.

We have binded the form field to the property so whenever the value changes, 
it will be reflected inside of the newWushText property. Now we need to
go to our component.ts file and add a new WishItem in the addNewWish
function and get the wishText from the property which is binded to the field.
After assigning the wishText, we clear it to allow the user to add another
wish if they want.

When we go to the browser and test our ap, we see that a new wish was added
to the list but we cannot see a text. If we check the console in devtools
we can see a clear error with a simple fix and we navigate to the html 
file and add a name atribute to our input element.

Now that we have thias funcionality we can comment out the hard coded 
items because we have ability to add items ourselves.

We also want to add a row div element which acts a container for our list.

Sometimes when we use ngModel, we want to be notified when that model value 
changes. For example we have used it for an input box which get a text and
its value is bound to a property in our component. We could make it so as 
the user types, we are notified of that change and get the value.

We want to use this functionality to set up a filter which provides 3
choices, one that shows all of the wishes, one that shows the fulfilled
wishes, and one that shows unfulfilled wishes.

First we uncomment the hard coded wishers to work with them. Then we add
the markup for the UI, then we use the ngModel on the select element and
use a property to bind it to, then we delcare the property as a string in
the component ts file and initialize it as 0 which selects the all mode.
Now we want to add a ngModelChange event which only occurs when the
model changes. We can only use it with ngModel directive. The event object
for this directive is not the typical object, it contains the new value.
So when the value of the model changes the option is going to be passed
to whatever method we choose.

We have filtered out the items that are displayed by declaring a new array
which only displays the visible items based on the mode that the user 
changes, but it has a few bugs, eg. when the user adds a new wish, they
have to refresh the page in order for the filter to work correctly.

The ngModelChange is a useful directive but it wasn't really suitable
for our filtering feature because it created two bugs. The only thing 
we had to do to take care of those bugs was to make sure that changes
to the iteams array (the original array) were reflected in the visibleItems
array. We can use a feature of JS instead of Angular to repurpose the visibleItems
array and make it a getter which is going to return an array which is 
dependent upon the filter.

Now that we have turned it into a getter, we must remove ngModelChange
from the html copmponent and also remove the function which handled
the changes to the filter, and also change the body for the getter.

Now we don't have to write code to make sure that the visibleItems array
is in sync with the items array because it is completely dependent on it.

If we look at the code and the template, there are three distinct pieces 
in our application. The user input, the filter, the displaying of our
items array. We say distinct pieces because they have their own functionality.
They all have the items array in common, but they do different things.

It is perfectly fine to create components that can be reused, but we use 
components for a variety of different reasons. First of all, we use 
components because they organize our application into smaller pieces.
So we're going to create three components.

We're going to start with the list and take it out. It is more than just
the list because it also handles the message that says there are no wishes
to display. So we take out the code for the list (essentially the ng-template)
element. Instead we add the wish-list element and we could supply the visible 
items to a property on this component called items. So we would have visible
items bound to a property called items.

It will also help simplify the code for this component because the toggleItem 
method can be extracted out. Now we want to create the component, we could do
it manually but there would be a lot of steps involved. We would have to create
the files and add the imports and handle the process of adding the decorator, etc.
We also need to modify the module file because we need to import any new component
that we add so that we can declare that and use it within the application.
Instead of doing all this work manually we can use the angular CLI for it:
    <ng generate component [component-name]>

Now if we navigate to the module file we would see that we are importing the
newly generated component, and it was also added to declarations. We didn't 
have to do any of that because the CLI does it for us.

Now we navigate to the html component file for the list of wishes and paste
the code that we have cut from the main html component file. This isn't going
to work with a property called visibleItems, it would work with a property
called items, because that's what we wanted to do when we modified the
main html component file. We can call it anything but it makes sense to
call it items. On second thought it would be better to call it wishes so
we can do that and replace the items property name with wishes.

-

The selector for the wish-list component is app-wish-list (automatically
generated by the CLI) so we can either leave that or just remove the app
prefix which is what we are going to do.  

We still have a couple of errors, some of which say that it can't bind to
wishes since it isn't a known property of wish-list. That makes sense because
we haven't defined a property called wishes. It makes us think that we
can solve it by defining it in the wish-list component file. However, it's
going to take care of one error since we have the same error inside of the
wishlist's template. If we took out that wishes property then we would have
an error on line 1 and 7 of the wish-list componet where we used wishes.
But that didn't take away the erro from the (main) app component. It still 
says can't bind to wishes.

There is one thing we have to consider about components that have input,
Even though we are providing input to a property called Wishes for the 
Wish-list component, we have to explicitly say that wishes is input. And
we do that by going to our wish-list component and we are going to use an
input decorator so we first import it on top. Then we decorate the properties
that we want to use as input. 

The next functionality that we want to extract as a component is the form
at the top of our application where the user enters their new wish. It is
going to be a bit different than the list because there is not going to be
any input but there will be some output. Because when the user clicks the
add wish button the component needs to tell the app component that it has
some new data which needs to be worked on. The way we do that is by creating
an event.

First of all let's create our new component and call it add-wish-form. To
create an event we have to use an event emitter. First we need to cut the
code for the form from the main app component, and replace it with sth else.
Then we use the event binding syntax, and whenever we think of event names,
first of all they are actions and also typically in the present tense. So
we will call this event addWish and add some code to it thta's going to
execute whenever this event happens. 

We will paste the form code into the new component, and we don't really
need to change its code. Now we need to navigate to the main app.component.ts
and cut newWishText and the addNewWish() method and put them inside the code
for the new component. We also remove the app prefix from the selector.

In the new component, we need to import the output decorator and also the
EventEmitter class. Another thing we need to do is import the WishItem class
so that we can work with that inside of our file. Now we have to write the 
code that is going to create our event and emit that event. 

In the add-wish-form component, where we define the output decorator, we new
up the eventemitter constructor and we can specify the type of object we're 
going to pass to it. We could say that we are going to pass a brand new 
WishItem object. So whenever we emit this addWish event, we will pass it a 
new wish item object that contains the new wish's text.

In the main app component template, where we write what happens when the
addWish event occurs, we could either call a function or noew that we just
need to do a simple thing, just write the code that needs to execute.

Extracting the functionality for the filter is going to be like the addWish 
form, since we won't have any input, we will have an output because the app 
component will need to know which filter is selected. To make this work, we
are going to need to use the ngModelChange event. We originally used this
directive to implement the filter and ran into some issues. And in this case
we will run into issues but they will be easy to fix.

We first create a component called wish-filter through the terminal. We will
cut almost all of the code from the main app component, and add the element
with the wish-filter name in their place. Then we paste the code in the 
wish-filter template file. We still need the ngModel but we will also need
to add ngModelChange, and we're going to define a method called changeFilter
that will give us the new value for our model. 

Then we will define the method in the wish-filter component.ts file, and this
is going to be where we are going to emit our filter event. Then we move all
of the files which belong in the wish-filter component and import Output and
EventEmitter. Now we need to keep track of the filter that's going to be
applied for the visible items. 

With the applied changes, the code must work well but there is a bug which is
when we open the web app, we cannot se any wishes and have to change between
the filters to be able to see some wishes. One quick fix is to nagivate to the 
component file and change the code to this:
  filter: any = () => true;
The other approach is to sue OnInit which is initialized in every component
that the tutor creates but not in mine so I won't go with that approach.

Now the app must be working correctly. We want to make another change, so we
navigate to the app component. We could get away without defining visibleItems,
we could define it here but we have been trying to simplify everything and also
a lot of the functionality was defined declaratively in the template as opposed
to programmatically.

So instead of using visibleItems in the wish-list element, we could simply
filter the items based upon our filter, which means that we will be able to
get rid of visibleItems, so we delete the code for visibleItems from the app
component which makes our code much cleaner.

So far we have discussed the inputs and outputs on our components, but we
haven't talked about how data flows from one component to the other. If we
take a look at the app component template, in the section where we use the
wish-list component, app is the parent and wish-list is the child. Wish-list
has a property which is the input and we are binding the items from the app 
component (the parent) to that wishes property. So in this case the flow of 
data goes from the parent to the child and there's no limit as to how far down
we can keep passing that information. 

Looking at add-wish-form and wish-filter, we have created events that emit
data whenever those events occur, and that is setting up the child to parent
communication. So with input, the information flows from parent to child, for
output, the information flows from child to parent.  

Looking at wish-filter, we've used ngModel in other places but we want to look
at this file for now, ngModel is a bit different than others as the syntax 
suggests, and it is because it uses the property binding as well as the event
binding syntax. So it implies that it is a two-way data binding. What we want 
to do now is to edit our wish filter so that it too has a two-way binding.

The reason why we want to do it here is primarily because of what we do when
this filter event occurs. All we are doing here is setting the app components
filter property equal to the filter that was provided though the event. It's
simple, so in this case it would make a lot of sense to set up some kind of
two-way binding, and we can do that easily by just using both input and 
output within our component.

Setting up two-way binding means that we have an input and an output, so we
need to change the name of our outputs but there is a rule that we have to
follow so that Angular will recognize that the input and the output are
linked together. The rule is the output has to be called the same name as our
input, followed by change. Now Angular should recognize that it's a two-way 
bindning. 

Now because we have changed the name of the event to filterChange, we have to
adjust our code and it's not really logical to have a filterChange event and
a method called changeFilter, so we will call the method updateFilter. Whenever
we update the filter, we want to do two things, we want to set the filter 
property equal to the new value that it should be. So in this case it would 
be filters[value], where value determines the index. Then we will emit the 
filterChange event, where we will pass in the property as the event object.

Earlier we said that we want to extract the functionality for the individual
items in the wishlist component into its own component. This is not a 
requirement. The tutor's personal preference is to extract something into a
component whenever they can, because it makes the app easier to maintain.

We want to get rid of the li elements and replace them with a wish-list-item
element, and use the ngFor in it without the index because it is not needed.
We want to have a property called wish in the wish-list component so that we
can bind the individual wish to, or we can provide the different pieces of
wish, we will do the latter. We can have a wishText property which we would
bind to the wish's wishText and also set up a two-way binding for the isComplete
property, and we can call that fulfilled.

Since we don't have the individual wish anymore, we will have the wishText in
the input element. We also have to import the WishItem class. We also need to
import Input, Output, and EventEmitter.

For the input, we need wishText which we are not going to initialize because
it is going to be supplied by the parent. We're going to use an exclamation-
mark which is known as non-null assertion operator to tell the compiler that
this property is a non-null property, which is a trick for the compiler here.

In the whole industry, not just with Angular, manipulating classes is the 
best way of manipulating style. We will define a class called strikeout on 
the css which has the text-decoration property to make changes to the style 
of the texts. (to draw a line through some of the texts)

The way we apply this css to the text, is with a directive called ngClass. 
This uses the square bracket syntax so it means that we are binding something
to a peroperty called ngClass on label. That means that whatever we use as 
the value for this ngClass attribute has to be a JavaScript expression. So
if we want to assign a css class, it would need to be a string so we surround
it with a pair of quotes. 

This approach draws a line through every single item and that's not what we
want, we want this to happen only to the items that are fulfilled. The first
thing we can do to accomplish this is use a ternary statement, because this is
a JS expression so we could check the value of fulfilled, and if it is fulfilled,
then we will apply the strikeout class, otherwise we won't apply any class.
The code for this is:
    [ngClass]="fulfilled ? 'strikeout' : ''"
This approach is hard to read so we will do another thing.

We can also define a property in our wish-list-item component, so we define a 
getter and name it cssClasses and then we can either use a ternary or return
an object where the property names are the css classes. And also the value is 
a conditional statement that determines whether or not that css class will be
applied to the element. We have also used text-muted from Bootstrap to make 
the color a bit transparent.
