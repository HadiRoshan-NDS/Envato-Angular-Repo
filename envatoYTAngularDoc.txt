The 4 component files collectively make up the component.
The file ending in spec.ts is for testing.

In the component html template file there is a span with {{ title }},
It is outputing the value that is assigned to a variable called title.
The title is defined in the app.component.ts file.

The @Component in the component.ts file is a decorator. It gives
us some information about the particular component. So this decorator
tells Agnular how this component is going to be used with selector.

In the index.html file line 11 there is a <app-root> element which
is the name of the selector which was defined in the AppComponent.

There are no hard rules for structuring our projects.

In the app.component.ts file the class is exported and in the
app.config.ts file the class and other things are imported.

Whenever we create our wishItem class, we need to export it, and
we'll call this class wishItem

We want the properties of the constructor to be accessible elsewhere
so the first thing that we do is make it public

In TS, we specify the type after we define the variable.

Regarding the two properties, whenever we define a wish item, we
pass the wishtext and denote whether or not it is completed.

After defining the wishItem class, we import it in the 
app.component.ts file and in the export class section we add an 
items array and pre-populate it with the constructor.

One benefit of TypeScript is that it provides information about
types and arguments and provides suggestions for you.

Material is Google's UI framework. But for the moment, we're going
to use Bootstrap instead of material which works fine. To use Bootstrap
in our project, we include it via cdn in our index.html file's head section.

JavaScript has a bunch of loops but the one that we typically use
is the for loop. And Angular gives us an easy way of using the for
of loop and we will use what's called a directive.

To use a directive, in the div element we use an asteriskng (*ng)
and it gives us some suggestions, the ones with the yellow icon 
are the ones that we work with (ngFor, ngIf, etc.).

The *ngFor directive is a structural directive because it changes the
structure of the DOM.

We can use the *ngIf directive to control the DOM, if the condition
we provide is true, then the element is going to be added to the document
and the content in the element will be rendered and visible. However, if
the condition is false, the element won't be rendered. We use this code:
<div *ngIf="items.length === 0">
    There are no wishes to display.
</div>

When there are no items to display and the array isn't rendered, the ul
element can be found in dev tools, to make that disappear we can type a 
ngIf condition in the ul element and say if the length of the array is
greater than 0, it is displayed.

The other approach for determining whether it is displayed or not is to
use this code instead: 
<div ngIf="items.length === 0, then noItems else showItems"></div>
<ng-template #noItems>
    There are no wishes to display.
</ng-template>
<ng-template #showItems>
    There are no wishes to display.
</ng-template>

*ngIf is also a structural directive because it changes the structure
of the document based upon the condition that is evaluated.

You cannot have two structural directives on the same element.

The way we work with data is that sometimes we want to display it and
sometimes we just want to work with it behind the scenes.

In our wish list application, we have two pieces of information that we
want to display. We want the text of the wish, we also want to show whether
or not that wish has been fulfilled.

In html, we add the checked attribute to the checkbox element to make it
be displayed as checked. 
Also on the JS side of things, this input element has a checked property.
That property is boolean. However, one thing to note is that if the html 
attribute is present, it is checked, regardless of its value. But the JS
property can be true or false which determines whether its checked or not.

To establish a connection between the isComplete property and the checked
attribute we should use property binding. We take the html attribute in 
this case checked and we sorround it with square brackets and the value 
that we assign to this is a JS expression that will determine whether or
not this check box is checked, that is the isComplete property.

When we want to bind something to the JS property of an object, we must
surround that property name with square brackets, assign the JS expression
that will then be bound to that property.

We can also bind to html attrtibutes. Let's say we wanted a custom attribute
called data-index; which would represent the index of the item in the 
array. We can get the index with the ng4 directive. To tdo this we surround
the attribute with square brackets and add attr. before the name of the 
attribute 

So we can bind data to an element's attribute or to its property.

Events are the most important part of an app with a GUI, because it is 
the primary way that the users interact with our app. 

The way we binded the checkbox with our js property was a one-way binding,
We are taking the value of isComplete and binding that to the checked 
property of the checkbox. So when the user clicks on the checkbox, it is
not updating the isComplete property. We need to write the code for that.

In order to bind an event it's going to be like the DOM level 0 event
handlers. If we wanted to handle the click event on an element, we would
use onclick. 

In Angular, we bind events like they way we bind properties and attributes.
Except instead of using brackets we use parentheses. The compiler is going
to suggest possible events that we can use and the names of them are just
plain events, they don't have the on prefix or stuff like that.

After naming the event in parentheses, we assign the JS code that is
going to execute which can be a function or an expression.

When it comes to DOM events, one of the things we typically do is 
access the event object that occurs because that gives us a lot of 
information about the event. What we have to do to get the information
is pass the event object. We do so by typing a $event in parentheses.

At first we passed $event (information about user when event occured)
to the toggleItem function to print it on the console, vut all we really
need is the item we work with, so we pass the item in the html.component.

After we edit the function to display the item in the console, we see the
information about the wish item such as wishText and isComplete, we can 
see that when the user clicks on the checkbox when if they click multiple
times, the isComplete value doesn't change so we have to update it manually.

To manually update the value of isComplete, we write a single line of 
code that toggles its value, so whenever it's clicked, the value changes
from true to false or vice-versa.

Forms, or working with forms are also one of the most important parts of'
the GUI. Events allow the users to interact with our application and forms
allow them to provide data to our application to work with.

Angular allows us to work with forms in two way, the first is called 
reactive forms which is more robust and scalable. For right now, we will
go with the second approach which is called template-driven forms. It 
allows us to define our forms inside of the template and we just reply
upon directives. 

We have added some code with Bootstrap in the component html file to create
a form for adding a wish. (The user just provide the wish text)

The first thing we want to do about this form is to handle the click (event).
We also have to prevent the form from being submitted, because that is the
default behavior of clicking a button inside of a form. To do this we use
preventDefault() with $event object to get access to it.

We can execute multiple statements on an event (click in this case) so we
first prevent the default behavior and then call a function for adding the
wish which we are going to declare in the component.

We need to find a way to bind data to this inpurt element. We do that with
syntax that essentially combines both the property binding syntax and the 
event binding syntax.
Now we need to tell Angular that we have this form field that we want to
bind to a property on our class, and we call it newWishText. Now we go
and define this property inside of our component class.

Even when we define newWishText in the ts component, we get and error:
"Can't bind to 'ngModel' since it isn't a known property of 'input'."
Now we have to open the app.module file which declares anything that
our application requires in order to run. 

In the NgModule decorator, declarations is a set of components or 
directives that belong to this particular module. AppComponent belongs 
this module because it has been declared here.

The imports are things that are available to the templates, inside of
this module. The providers are objects that can be injected to parts of
this module. The [AppComponent] is the entry point to this module.

What we need to do to be able to use the NgModel directive, is import the
FormsModule, and vscode suggests the code we need for that. In order to 
import, we have to import it on top of the file, and also in the import
section of the decorator.

We have binded the form field to the property so whenever the value changes, 
it will be reflected inside of the newWushText property. Now we need to
go to our component.ts file and add a new WishItem in the addNewWish
function and get the wishText from the property which is binded to the field.
After assigning the wishText, we clear it to allow the user to add another
wish if they want.

When we go to the browser and test our ap, we see that a new wish was added
to the list but we cannot see a text. If we check the console in devtools
we can see a clear error with a simple fix and we navigate to the html 
file and add a name atribute to our input element.

Now that we have thias funcionality we can comment out the hard coded 
items because we have ability to add items ourselves.

We also want to add a row div element which acts a container for our list.

Sometimes when we use ngModel, we want to be notified when that model value 
changes. For example we have used it for an input box which get a text and
its value is bound to a property in our component. We could make it so as 
the user types, we are notified of that change and get the value.

We want to use this functionality to set up a filter which provides 3
choices, one that shows all of the wishes, one that shows the fulfilled
wishes, and one that shows unfulfilled wishes.

First we uncomment the hard coded wishers to work with them. Then we add
the markup for the UI, then we use the ngModel on the select element and
use a property to bind it to, then we delcare the property as a string in
the component ts file and initialize it as 0 which selects the all mode.
Now we want to add a ngModelChange event which only occurs when the
model changes. We can only use it with ngModel directive. The event object
for this directive is not the typical object, it contains the new value.
So when the value of the model changes the option is going to be passed
to whatever method we choose.

We have filtered out the items that are displayed by declaring a new array
which only displays the visible items based on the mode that the user 
changes, but it has a few bugs, eg. when the user adds a new wish, they
have to refresh the page in order for the filter to work correctly.

The ngModelChange is a useful directive but it wasn't really suitable
for our filtering feature because it created two bugs. The only thing 
we had to do to take care of those bugs was to make sure that changes
to the iteams array (the original array) were reflected in the visibleItems
array. We can use a feature of JS instead of Angular to repurpose the visibleItems
array and make it a getter which is going to return an array which is 
dependent upon the filter.

Now that we have turned it into a getter, we must remove ngModelChange
from the html copmponent and also remove the function which handled
the changes to the filter, and also change the body for the getter.

Now we don't have to write code to make sure that the visibleItems array
is in sync with the items array because it is completely dependent on it.


