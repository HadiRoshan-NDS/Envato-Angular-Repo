The 4 component files collectively make up the component.
The file ending in spec.ts is for testing.

In the component html template file there is a span with {{ title }},
It is outputing the value that is assigned to a variable called title.
The title is defined in the app.component.ts file.

The @Component in the component.ts file is a decorator. It gives
us some information about the particular component. So this decorator
tells Agnular how this component is going to be used with selector.

In the index.html file line 11 there is a <app-root> element which
is the name of the selector which was defined in the AppComponent.

There are no hard rules for structuring our projects.

In the app.component.ts file the class is exported and in the
app.config.ts file the class and other things are imported.

Whenever we create our wishItem class, we need to export it, and
we'll call this class wishItem

We want the properties of the constructor to be accessible elsewhere
so the first thing that we do is make it public

In TS, we specify the type after we define the variable.

Regarding the two properties, whenever we define a wish item, we
pass the wishtext and denote whether or not it is completed.

After defining the wishItem class, we import it in the 
app.component.ts file and in the export class section we add an 
items array and pre-populate it with the constructor.

One benefit of TypeScript is that it provides information about
types and arguments and provides suggestions for you.

Material is Google's UI framework. But for the moment, we're going
to use Bootstrap instead of material which works fine. To use Bootstrap
in our project, we include it via cdn in our index.html file's head section.

JavaScript has a bunch of loops but the one that we typically use
is the for loop. And Angular gives us an easy way of using the for
of loop and we will use what's called a directive.

To use a directive, in the div element we use an asteriskng (*ng)
and it gives us some suggestions, the ones with the yellow icon 
are the ones that we work with (ngFor, ngIf, etc.).

The *ngFor directive is a structural directive because it changes the
structure of the DOM.

We can use the *ngIf directive to control the DOM, if the condition
we provide is true, then the element is going to be added to the document
and the content in the element will be rendered and visible. However, if
the condition is false, the element won't be rendered. We use this code:
<div *ngIf="items.length === 0">
    There are no wishes to display.
</div>

When there are no items to display and the array isn't rendered, the ul
element can be found in dev tools, to make that disappear we can type a 
ngIf condition in the ul element and say if the length of the array is
greater than 0, it is displayed.

The other approach for determining whether it is displayed or not is to
use this code instead: 
<div ngIf="items.length === 0, then noItems else showItems"></div>
<ng-template #noItems>
    There are no wishes to display.
</ng-template>
<ng-template #showItems>
    There are no wishes to display.
</ng-template>

*ngIf is also a structural directive because it changes the structure
of the document based upon the condition that is evaluated.

You cannot have two structural directives on the same element.

The way we work with data is that sometimes we want to display it and
sometimes we just want to work with it behind the scenes.

In our wish list application, we have two pieces of information that we
want to display. We want the text of the wish, we also want to show whether
or not that wish has been fulfilled.

In html, we add the checked attribute to the checkbox element to make it
be displayed as checked. 
Also on the JS side of things, this input element has a checked property.
That property is boolean. However, one thing to note is that if the html 
attribute is present, it is checked, regardless of its value. But the JS
property can be true or false which determines whether its checked or not.

To establish a connection between the isComplete property and the checked
attribute we should use property binding. We take the html attribute in 
this case checked and we sorround it with square brackets and the value 
that we assign to this is a JS expression that will determine whether or
not this check box is checked, that is the isComplete property.

When we want to bind something to the JS property of an object, we must
surround that property name with square brackets, assign the JS expression
that will then be bound to that property.

We can also bind to html attrtibutes. Let's say we wanted a custom attribute
called data-index; which would represent the index of the item in the 
array. We can get the index with the ng4 directive. To tdo this we surround
the attribute with square brackets and add attr. before the name of the 
attribute 

So we can bind data to an element's attribute or to its property.

Events are the most important part of an app with a GUI, because it is 
the primary way that the users interact with our app. 

The way we binded the checkbox with our js property was a one-way binding,
We are taking the value of isComplete and binding that to the checked 
property of the checkbox. So when the user clicks on the checkbox, it is
not updating the isComplete property. We need to write the code for that.

In order to bind an event it's going to be like the DOM level 0 event
handlers. If we wanted to handle the click event on an element, we would
use onclick. 

In Angular, we bind events like they way we bind properties and attributes.
Except instead of using brackets we use parentheses. The compiler is going
to suggest possible events that we can use and the names of them are just
plain events, they don't have the on prefix or stuff like that.

After naming the event in parentheses, we assign the JS code that is
going to execute which can be a function or an expression.

When it comes to DOM events, one of the things we typically do is 
access the event object that occurs because that gives us a lot of 
information about the event. What we have to do to get the information
is pass the event object. We do so by typing a $event in parentheses.

At first we passed $event (information about user when event occured)
to the toggleItem function to print it on the console, vut all we really
need is the item we work with, so we pass the item in the html.component.

After we edit the function to display the item in the console, we see the
information about the wish item such as wishText and isComplete, we can 
see that when the user clicks on the checkbox when if they click multiple
times, the isComplete value doesn't change so we have to update it manually.

To manually update the value of isComplete, we write a single line of 
code that toggles its value, so whenever it's clicked, the value changes
from true to false or vice-versa.

Forms, or working with forms are also one of the most important parts of'
the GUI. Events allow the users to interact with our application and forms
allow them to provide data to our application to work with.

Angular allows us to work with forms in two way, the first is called 
reactive forms which is more robust and scalable. For right now, we will
go with the second approach which is called template-driven forms. It 
allows us to define our forms inside of the template and we just reply
upon directives. 

We have added some code with Bootstrap in the component html file to create
a form for adding a wish. (The user just provide the wish text)

The first thing we want to do about this form is to handle the click (event).
We also have to prevent the form from being submitted, because that is the
default behavior of clicking a button inside of a form. To do this we use
preventDefault() with $event object to get access to it.

We can execute multiple statements on an event (click in this case) so we
first prevent the default behavior and then call a function for adding the
wish which we are going to declare in the component.

We need to find a way to bind data to this inpurt element. We do that with
syntax that essentially combines both the property binding syntax and the 
event binding syntax.
Now we need to tell Angular that we have this form field that we want to
bind to a property on our class, and we call it newWishText. Now we go
and define this property inside of our component class.

Even when we define newWishText in the ts component, we get and error:
"Can't bind to 'ngModel' since it isn't a known property of 'input'."
Now we have to open the app.module file which declares anything that
our application requires in order to run. 

In the NgModule decorator, declarations is a set of components or 
directives that belong to this particular module. AppComponent belongs 
this module because it has been declared here.

The imports are things that are available to the templates, inside of
this module. The providers are objects that can be injected to parts of
this module. The [AppComponent] is the entry point to this module.

What we need to do to be able to use the NgModel directive, is import the
FormsModule, and vscode suggests the code we need for that. In order to 
import, we have to import it on top of the file, and also in the import
section of the decorator.

We have binded the form field to the property so whenever the value changes, 
it will be reflected inside of the newWushText property. Now we need to
go to our component.ts file and add a new WishItem in the addNewWish
function and get the wishText from the property which is binded to the field.
After assigning the wishText, we clear it to allow the user to add another
wish if they want.

When we go to the browser and test our ap, we see that a new wish was added
to the list but we cannot see a text. If we check the console in devtools
we can see a clear error with a simple fix and we navigate to the html 
file and add a name atribute to our input element.

Now that we have thias functionality we can comment out the hard coded 
items because we have ability to add items ourselves.

We also want to add a row div element which acts a container for our list.

Sometimes when we use ngModel, we want to be notified when that model value 
changes. For example we have used it for an input box which get a text and
its value is bound to a property in our component. We could make it so as 
the user types, we are notified of that change and get the value.

We want to use this functionality to set up a filter which provides 3
choices, one that shows all of the wishes, one that shows the fulfilled
wishes, and one that shows unfulfilled wishes.

First we uncomment the hard coded wishers to work with them. Then we add
the markup for the UI, then we use the ngModel on the select element and
use a property to bind it to, then we delcare the property as a string in
the component ts file and initialize it as 0 which selects the all mode.
Now we want to add a ngModelChange event which only occurs when the
model changes. We can only use it with ngModel directive. The event object
for this directive is not the typical object, it contains the new value.
So when the value of the model changes the option is going to be passed
to whatever method we choose.

We have filtered out the items that are displayed by declaring a new array
which only displays the visible items based on the mode that the user 
changes, but it has a few bugs, eg. when the user adds a new wish, they
have to refresh the page in order for the filter to work correctly.

The ngModelChange is a useful directive but it wasn't really suitable
for our filtering feature because it created two bugs. The only thing 
we had to do to take care of those bugs was to make sure that changes
to the iteams array (the original array) were reflected in the visibleItems
array. We can use a feature of JS instead of Angular to repurpose the visibleItems
array and make it a getter which is going to return an array which is 
dependent upon the filter.

Now that we have turned it into a getter, we must remove ngModelChange
from the html copmponent and also remove the function which handled
the changes to the filter, and also change the body for the getter.

Now we don't have to write code to make sure that the visibleItems array
is in sync with the items array because it is completely dependent on it.

If we look at the code and the template, there are three distinct pieces 
in our application. The user input, the filter, the displaying of our
items array. We say distinct pieces because they have their own functionality.
They all have the items array in common, but they do different things.

It is perfectly fine to create components that can be reused, but we use 
components for a variety of different reasons. First of all, we use 
components because they organize our application into smaller pieces.
So we're going to create three components.

We're going to start with the list and take it out. It is more than just
the list because it also handles the message that says there are no wishes
to display. So we take out the code for the list (essentially the ng-template)
element. Instead we add the wish-list element and we could supply the visible 
items to a property on this component called items. So we would have visible
items bound to a property called items.

It will also help simplify the code for this component because the toggleItem 
method can be extracted out. Now we want to create the component, we could do
it manually but there would be a lot of steps involved. We would have to create
the files and add the imports and handle the process of adding the decorator, etc.
We also need to modify the module file because we need to import any new component
that we add so that we can declare that and use it within the application.
Instead of doing all this work manually we can use the angular CLI for it:
    <ng generate component [component-name]>

Now if we navigate to the module file we would see that we are importing the
newly generated component, and it was also added to declarations. We didn't 
have to do any of that because the CLI does it for us.

Now we navigate to the html component file for the list of wishes and paste
the code that we have cut from the main html component file. This isn't going
to work with a property called visibleItems, it would work with a property
called items, because that's what we wanted to do when we modified the
main html component file. We can call it anything but it makes sense to
call it items. On second thought it would be better to call it wishes so
we can do that and replace the items property name with wishes.

-

The selector for the wish-list component is app-wish-list (automatically
generated by the CLI) so we can either leave that or just remove the app
prefix which is what we are going to do.  

We still have a couple of errors, some of which say that it can't bind to
wishes since it isn't a known property of wish-list. That makes sense because
we haven't defined a property called wishes. It makes us think that we
can solve it by defining it in the wish-list component file. However, it's
going to take care of one error since we have the same error inside of the
wishlist's template. If we took out that wishes property then we would have
an error on line 1 and 7 of the wish-list componet where we used wishes.
But that didn't take away the erro from the (main) app component. It still 
says can't bind to wishes.

There is one thing we have to consider about components that have input,
Even though we are providing input to a property called Wishes for the 
Wish-list component, we have to explicitly say that wishes is input. And
we do that by going to our wish-list component and we are going to use an
input decorator so we first import it on top. Then we decorate the properties
that we want to use as input. 

The next functionality that we want to extract as a component is the form
at the top of our application where the user enters their new wish. It is
going to be a bit different than the list because there is not going to be
any input but there will be some output. Because when the user clicks the
add wish button the component needs to tell the app component that it has
some new data which needs to be worked on. The way we do that is by creating
an event.

First of all let's create our new component and call it add-wish-form. To
create an event we have to use an event emitter. First we need to cut the
code for the form from the main app component, and replace it with sth else.
Then we use the event binding syntax, and whenever we think of event names,
first of all they are actions and also typically in the present tense. So
we will call this event addWish and add some code to it thta's going to
execute whenever this event happens. 

We will paste the form code into the new component, and we don't really
need to change its code. Now we need to navigate to the main app.component.ts
and cut newWishText and the addNewWish() method and put them inside the code
for the new component. We also remove the app prefix from the selector.

In the new component, we need to import the output decorator and also the
EventEmitter class. Another thing we need to do is import the WishItem class
so that we can work with that inside of our file. Now we have to write the 
code that is going to create our event and emit that event. 

In the add-wish-form component, where we define the output decorator, we new
up the eventemitter constructor and we can specify the type of object we're 
going to pass to it. We could say that we are going to pass a brand new 
WishItem object. So whenever we emit this addWish event, we will pass it a 
new wish item object that contains the new wish's text.

In the main app component template, where we write what happens when the
addWish event occurs, we could either call a function or noew that we just
need to do a simple thing, just write the code that needs to execute.

Extracting the functionality for the filter is going to be like the addWish 
form, since we won't have any input, we will have an output because the app 
component will need to know which filter is selected. To make this work, we
are going to need to use the ngModelChange event. We originally used this
directive to implement the filter and ran into some issues. And in this case
we will run into issues but they will be easy to fix.

We first create a component called wish-filter through the terminal. We will
cut almost all of the code from the main app component, and add the element
with the wish-filter name in their place. Then we paste the code in the 
wish-filter template file. We still need the ngModel but we will also need
to add ngModelChange, and we're going to define a method called changeFilter
that will give us the new value for our model. 

Then we will define the method in the wish-filter component.ts file, and this
is going to be where we are going to emit our filter event. Then we move all
of the files which belong in the wish-filter component and import Output and
EventEmitter. Now we need to keep track of the filter that's going to be
applied for the visible items. 

With the applied changes, the code must work well but there is a bug which is
when we open the web app, we cannot se any wishes and have to change between
the filters to be able to see some wishes. One quick fix is to nagivate to the 
component file and change the code to this:
  filter: any = () => true;
The other approach is to sue OnInit which is initialized in every component
that the tutor creates but not in mine so I won't go with that approach.

Now the app must be working correctly. We want to make another change, so we
navigate to the app component. We could get away without defining visibleItems,
we could define it here but we have been trying to simplify everything and also
a lot of the functionality was defined declaratively in the template as opposed
to programmatically.

So instead of using visibleItems in the wish-list element, we could simply
filter the items based upon our filter, which means that we will be able to
get rid of visibleItems, so we delete the code for visibleItems from the app
component which makes our code much cleaner.

So far we have discussed the inputs and outputs on our components, but we
haven't talked about how data flows from one component to the other. If we
take a look at the app component template, in the section where we use the
wish-list component, app is the parent and wish-list is the child. Wish-list
has a property which is the input and we are binding the items from the app 
component (the parent) to that wishes property. So in this case the flow of 
data goes from the parent to the child and there's no limit as to how far down
we can keep passing that information. 

Looking at add-wish-form and wish-filter, we have created events that emit
data whenever those events occur, and that is setting up the child to parent
communication. So with input, the information flows from parent to child, for
output, the information flows from child to parent.  

Looking at wish-filter, we've used ngModel in other places but we want to look
at this file for now, ngModel is a bit different than others as the syntax 
suggests, and it is because it uses the property binding as well as the event
binding syntax. So it implies that it is a two-way data binding. What we want 
to do now is to edit our wish filter so that it too has a two-way binding.

The reason why we want to do it here is primarily because of what we do when
this filter event occurs. All we are doing here is setting the app components
filter property equal to the filter that was provided though the event. It's
simple, so in this case it would make a lot of sense to set up some kind of
two-way binding, and we can do that easily by just using both input and 
output within our component.

Setting up two-way binding means that we have an input and an output, so we
need to change the name of our outputs but there is a rule that we have to
follow so that Angular will recognize that the input and the output are
linked together. The rule is the output has to be called the same name as our
input, followed by change. Now Angular should recognize that it's a two-way 
bindning. 

Now because we have changed the name of the event to filterChange, we have to
adjust our code and it's not really logical to have a filterChange event and
a method called changeFilter, so we will call the method updateFilter. Whenever
we update the filter, we want to do two things, we want to set the filter 
property equal to the new value that it should be. So in this case it would 
be filters[value], where value determines the index. Then we will emit the 
filterChange event, where we will pass in the property as the event object.

Earlier we said that we want to extract the functionality for the individual
items in the wishlist component into its own component. This is not a 
requirement. The tutor's personal preference is to extract something into a
component whenever they can, because it makes the app easier to maintain.

We want to get rid of the li elements and replace them with a wish-list-item
element, and use the ngFor in it without the index because it is not needed.
We want to have a property called wish in the wish-list component so that we
can bind the individual wish to, or we can provide the different pieces of
wish, we will do the latter. We can have a wishText property which we would
bind to the wish's wishText and also set up a two-way binding for the isComplete
property, and we can call that fulfilled.

Since we don't have the individual wish anymore, we will have the wishText in
the input element. We also have to import the WishItem class. We also need to
import Input, Output, and EventEmitter.

For the input, we need wishText which we are not going to initialize because
it is going to be supplied by the parent. We're going to use an exclamation-
mark which is known as non-null assertion operator to tell the compiler that
this property is a non-null property, which is a trick for the compiler here.

In the whole industry, not just with Angular, manipulating classes is the 
best way of manipulating style. We will define a class called strikeout on 
the css which has the text-decoration property to make changes to the style 
of the texts. (to draw a line through some of the texts)

The way we apply this css to the text, is with a directive called ngClass. 
This uses the square bracket syntax so it means that we are binding something
to a property called ngClass on label. That means that whatever we use as 
the value for this ngClass attribute has to be a JavaScript expression. So
if we want to assign a css class, it would need to be a string so we surround
it with a pair of quotes. 

This approach draws a line through every single item and that's not what we
want, we want this to happen only to the items that are fulfilled. The first
thing we can do to accomplish this is use a ternary statement, because this is
a JS expression so we could check the value of fulfilled, and if it is fulfilled,
then we will apply the strikeout class, otherwise we won't apply any class.
The code for this is:
    [ngClass]="fulfilled ? 'strikeout' : ''"
This approach is hard to read so we will do another thing.

We can also define a property in our wish-list-item component, so we define a 
getter and name it cssClasses and then we can either use a ternary or return
an object where the property names are the css classes. And also the value is 
a conditional statement that determines whether or not that css class will be
applied to the element. We have also used text-muted from Bootstrap to make 
the color a bit transparent.

We want to add functionality to remove individual wishes from the list. We 
have to add a button for each item on the list, then whenever we click on 
that button, we issue an event. We have an issue which is we have the 
individual wishes in the wish-list-item component but we have defined the
array of wishes in the app component so we have to manipulate the array from
there. These two components are not directly related so we cannot necessarily
define an event inside of the wish-list-item component and then listen for 
that in the app component. 

We have two options, The first would be to define a remove item event inside 
of the wish-list-item component so that we can issue that event and listen for 
it inside of the wish-list. But the wish-list component doesn't care about that
event because it gets its wishes from the app component. We would need to define
that remove wish event on the wish-list-item and then on the wish-list so that 
the app component could listen to it on the wish-list. That's not scalable at 
all it would be a disaster. 

The more feasible solution would be to create an event bus. It's a global-object
that lets you issue events from anywhere within the application and listen for
those events anywhere within the application, and the way we can do that is by 
using observable objects. What the observer pattern essentially is, it is an 
object that needs to supply data to other objects. So the other objects subscribe
to the observer object, and when those changes occur it notifies the subscriber.
If that sound like an event, it's because it is an event. Every time we have
used the event emitter we have used an observable object. However in this
lesson we are going to use the observable type directly. 

We'll navigate to the shared directory, create a new folder there and we'll 
call it services, and inside of services we will create a new file called event
service. Now first let's navigate to the wish-list-item component and let's
modify our template here so we have our delete button. When we create the
buttons using bootstrap in the template, it is created as a block element so
it goes to a new line, so we use flexbox and d-flex then justify content between.
When we do this the close buttons are going to be very far on the right side,

We'll navigate to the app component template and add another div element. We
have used this <col-sm-4> Bootstrap class to change the location of the X's 
on the screen, and now we can define the click event for this button.

Now we can see that going with the option of providing the wish text and the 
value for fulfilled property wasn't the best approach. We should probably just
use the wish object itself an input. We'll do that later.

The concept with the event bus is very similar to what we have with normal
events in that we are going to emit an event called removeWish, and then we
are providing information involved with that remove wish event which in this 
case is going to be the wish text. 

Now we navigate to the app component to write the code for listening for that
event. We can do this inside of the constructor, so we would have our events
and we would listen for the remove wish event, and we would have a callback 
function because that's typically what we would have. We could define a method
for this or just provide the callback function inline. So eventually we would 
get the wish and remove wish from items. So that's the API we want to use, so
now we just need to implement that inside of our EventService file. 

First we need to import Observable and Subject. These are being imported from
RxJS. This is the Reactive Extensions for JS, which Angular uses extensively.
And in fact it uses Observable extensively not just for events. Whenever we
talk about HTTP requests it uses Observable then it is used throughout the 
framework. Subject is a special type of Observable object. This is essentially
going to allow us to emulate typical events so that we can have multiple 
objects that subscribe to our Observable object. Meaning that we can issue a 
single event and multiple objects can be listening for that same event.

We wil define the class inside the EventService file, we don't need to inherit 
anything, but we do need the Subject. We ned the Subject which is essentially
going to allow us to pass messages from the Observable object to the subscriber
object. We use the term message because that's essentially what an event is.

We use the emit emthod where we would have the eventName as a string and also
we have the payload for as of type any. We also hae the listen event which has
eventName as string and then the callback function. And we define this function
having an event of type any which returns void. 

To emit an event we're going to use this.subject and anytime we want to emit
and event we call a method called next, we pass in the object that we want the
subscribers to work with. So in this case we have eventName and the payload.
So whatever obejct is going to subscribe to an event is going to get an object
with these two properties. We're going to simplify it for those subscribers.

In the listen method, we are going to use our subject and there's a method called
asObservable, and this is going to give us access to a subscribe method. And
this subscribe method by default acceps a callback function that will accept 
whatever we pass to the next method. So we will have nextObj for the subscribe
function, and inside of the callback function we are going to check if the given
events name is equal to the events name that comes from the nextObj.

Now we have to first export EventService in its file and then import events 
in app component and the wish-list-item component.

When our application doesn't work as expected, we can add <debugger;> in our
code to help us find the problem, it works like a break point . We can then 
use the dev tools, sources tab, navigate to the correct file and move forward
in steps to find the problem.

Now that we have set up our event bus, we can emit the desired event from 
anywhere in our application and also listen for it from anywhere in our 
application. Next we will have to modify the wish-list component and work 
with the object itself. Because if those are equal, then we want to call the
provided callback function where we will pass in the payload from the nextObj.

Since the app currently works with the individual pieces of the wish, we have
to find a way to identify the wish that we want to remove and work with the
whole object. There are a couple of different ways for us to do this, one would
be to supply some kind of unique identifier for each wish which in a real app
that's what we would have, because the information would be coming from some 
kind of data store. However, it would be okay if we forego the individual pieces 
and provide the actual wish object to the wish list item.

We will modify the code in wish-list-item component, remove the wishText property,
then we won't have the two-way binding for fulfilled and refactoring seems like
we are doing all the work we have done, but it was good practice.

For the css classes we're gonna base them upon the wishes isComplete property.
For the removeWish, we can pass in the wish object that we will get. For toggling
fulfilled, we can leave the method there and modify its code to work with the
isComplete property. Also for accessing the text and fulfilled in the 
wish-list-item component, we will access them through the wish object. We also
need to modify the code in the wish-list component and just pass the wish.

Then we will modify the code for the constructor function in the app component
to get the index of the item that we want to remove and then remove it with
the splice method. Now we have successfully implemeneted the functionaliy 
for removing items from the list.

Dependency Injection has become the norm in modern sw development. All modern 
frameworks have this feature regardless of whether you're using SSR or CSR.
To understand dependency, we have to take a look at our event bus. We have this
EventService class and then we export an object that we create (new EventService())
So we are creating an actual object which we are importing in the wish-list-item
component and the app component. And we are using that object to listen for the
remove wish event and to emit that remove wish event. So this actual  event 
object, is a dependency in the app and wish-list-item components. We could say
that it is a hard dependency because we have created that object, and we are
using that object inside of those components. 

Hard dependencies can be a little problematic because it can make the code a
little bit more difficult to maintain and update. But it can also cause some
issues whenever we need to test our components. So we want to use Dependendcy
Injection service to avoid creating dependencies ourselves. This way we can
tell Angular what it is that we want to use and then it will automatically 
inject our dependencies. 

So for our wish-list-item component we want to import that event service class.
In order to do that, we ned to first export that class. In the constructor we
say that we want an object called events, and we want it to be of type event 
service, and we're going to say that it's private events, so that it will 
automatically that property for us, so that we don't have to create that 
object. All we ahve to say is I want this wishlist component to rely upon this
dependency and Angular will automatically provide that object for us. We could
do the same thing in the app component, we would once again import the event
service class and then in the constructor we would say that we want an object
called events of type EventService. In this case we don't need to create a 
property because we're using events here directly inside of the constructor.
That's what we want, for Angular to create the dependencies for us.

So the next thing we need to do is go to our EventService and get rid of the 
export statement and export the class itself. But we'll get an error which 
says "no suitable injection token for parameter 'events' of class 'AppComponent'"
It means that it can't inject he event service because it doesn't know it can.
It's not an automatic thing, so what we need to do is mark the EventService
class with the @Injectable decorator which is going to tell Angular that this
class can be injected into other classes. 

So using the Injectable decorator is good but it is not enough, we can go to 
our AppModule and we could import that event service and then we could add 
that event service to the providers array. That is one way to do it, but,
Whenever we use the Injectable decorator, we can specify where we want to be
able to inject that class. All we have to do is pass an object that has a 
property called providedIn, ant his enables us to do what we wanted. If we 
provide a string called root <'root'>, it would be an app level injector, so
this essentially means that the EventService would be available throughout the
entire application. Alternatives for root would be platform, since we might
have multiple applications in a single page and want to use it in all of them.

One of the most common things we do in our client apps is interact with the 
server. We issue HTTP requests to fetch data or manipulate that data. Angular
has a built-in HTTP client. Technically every framework has an HTTP client 
because we have the Fetch API that's built into the browser. React and View
don't have a built-in HTTP client and you have to use third party client or
you can just use the Fetch API. For Angular we can import the HTTP client
module. After we import it we can add it as an element to the imports array.

Currently, we have the items array inside of our app component which is hard-
coded to have individual wishes. Instead I would like to fetch this information
from a JSON file. Ideally we would have a web server for CRUD reqs but we don't.
So for now we will have a JSON file that has that same information. We will 
fetch that information and then use it to populate the items array. 

Let's go to our assets folder and create a file called wishes.json and paste
the hard-coded items. Now we don't want to work with the JSON file manually,
so we would define a service which handles the HTTP requests for it. We can 
generate a service by turning to the CLI and type <ng generate service [name]>
which creates two new files in the app folder. The generated service is 
injectable by default and we will import it in the app component and inject it
to the constructor as a property and name it wishService of the type WishService.

We need to writ ethe code that's going to fetch the json file. Inside the new
service we importy the HttpClient and this is injectable so we can inject that
into our constructor here. So we would use our HTTP object which has a variety 
of methods, in this case we want to make a gre request so we specify the url
that we want to make a request for that is our assets and then wishes.json.
We would also want to return the result of the get method. 

Now the get method returns an observable and by calling the get method, the 
actual request has not been sent yet. Since this is an observable object we can
call the subscribe method, the the request is sent. 

Now what we want to do is make our http request with the OnInit method. The
OnInit method was a method that executes so that we can perform other initialiation
processes. One of those things could be making an HTTP request. So we want to
implement OnInit in our app component, 

When it comes to HTTP Requests, we rarely just issue a simple get request like
we did, instead we usually have to supply some options involved, such as special
headers or an authorization token. It varies depending upon our server application
and what it needs. But a lot of the time we are supplying some other information
here. Since we don't have a server all of our reuqests would be of the type get
but the principles can be applied everywhere.

The only difference between a get request and a post request is we provide the
request body as the second argument. The first argument is always the url, and
the last argument is the options we may or may not want to provide. We can have
a method that generates the standard options we need for every request. So we
are going to define getStandardOptions which needs to return an object made of
several options. 

One of the options is typically the header. If we don't have the correct headers
sometimes our request is going to fail. We have a class called http headers,
and in order to use that we are going to need to import it first. 

The constructor in web services, accepts an object where the property names
are the names of the headers and the values. We can specify the content type
or a token we may need in these headers. 

We define a fake mthod for adding a wish called addWish(), where we will accept
the wish object as the agurment, this will be a WishItem which we need to import. 
This is typically where we would use post, and in this case we would need that
authorization header. Retrieving wishes doesn't require auhtorization but adding
a wish does. When we access options header here, we can use the set method on 
it and add an option. 

We make the addWish method private so we wouldn't be able to call it from 
outside of the class. Another common option that we use are URL parameters and
this is especially true for get requests. For example if we weren't actually
fetching a JSON file, we were hitting some kind of web service, but we were able
to specify the format that we wanted the data in. We could have a format URL
parameter and then we could set that to JSON or something else. We could add that
to the URL or modify the params object which is of type HttpParams. Whenever we 
use this constructor we can pass in an object that has various options, the most 
used would be the fromObject.This object says that we want to create our URL 
parameters from this object where the property names are the URL parameter names,
and their values are their values. So using the object we have just defined, we
can send a request using the provided URL, except that we don't have to specify
the query portion of that URL. 

Handling errors is an important part of software development. Errors happen and
they might not be our fault, especially with HTTP requests. We should at least
provide some information to the user that whatever you wanted to do didn't work.

The first thing we want to do about errors, is in the app component file, provide
a second callback function to the subscribe method. The first callback function is 
handling the response on a successful request. If there is something that goes 
wrong, we need to handle that error, and we can do that bt providing a second
method which is another callback function that receives the error object and it 
has a message property that we can provide to the user. 

Now we'll go to the wish service file and make a request to a file that does not
exist. So we change the name of the file from wishes.json to wishes1.json. When
we save it and load the Angular application, we'll see the result of that request
which will be "Http failure response 404 Not Found". The users are not technical
people so we need to provide a meaningful message for them...

- THE REST OF THE NOTES FOR HTTPS

When it comes to building applications, modules are one of those things that we
don't necessarily need them, but they are extremely useful for very large 
applications. Because it allows us to create a container for closely related
componens and functionality. For example, so far in this application we have been
focusing on the wish list and everything that has to do with them, if we were going
to build more functionality for this application that doesn't work with the wishes,
like a contact form, it would be logical to create a module that serves as a 
container for all of the wish oriented stuff. So everything we have done as far as
working with wishes would be inside a module, then we could create another module
for all of the contact form stuff. 

We can create a module through the command line using ng generate module, specify
the name of the module and run the command. Then the CLI is going to create a
directory inside of our app directory called wish, with one module file. Now that
we have created this module we want to put everything we have worked on thus far
in this folder, the folders with wish in their names and also in shared.

In the app module file, we want to take some of the import statements where we are
importing components, we will cut them and paste them in the new wish module. We
also need to move the declarations and also move HttpClient and Forms imports to
the new module along with their import array. 

Importing the components in the new module is not good enough, we need to also 
export it, so we'll create an exports array and specify each one of these 
components that we want to export. 

- THE REST OF THE NOTES FOR MODULES

We want to extract just about everything about our wish list application into the
wish module. Even taking what we currently have inside of the AppComponent, and
putting that inside of a new component called wish inside of the wish module. That
way all we have to do is drop that component into the app component so we would 
have something like <wish-app></wish-app> in the app.component.html file.

First thing that we want to do is we want to create a component and call it wish,
and put it inside of the wish module. The command we need for this is:
    <ng generate component wish -m wish>
In the project we have an app module and app component so we want to keep the same
pattern and create a wish component inside a wish module. What we want to do now
is move the template from our app component to our newly created wish component.

Now that we have moved that code, we need to modify our components, first we need 
to move the code for impoerting WishItem, EventService, and WishService to our
wish component, and also edit the paths for the import statements. We also need to
move the code in the body of the AppComponent class in the app component file to
the wish compoennt file. 

Now we want to navigate to the wish module and whatever is going to use this wish
module doesn't necessarily care about the 4 components exported in this module, so
all we need to export is the wish component. 

In this section we want to discuss forms. When we created the Add-Wish-Compoennt,
we used the template-driven approach. We used the ngModule directive, assigned that
property to our component class and then created that two-way binding between the
form field and the property. While this approach works for simple forms, we 
typically don't want to use it for larger forms, especially if our application is 
very forms heavy. 

One of the disadvantages with template driven approach is that it has performance
hit, there's a lot of overhead to manage the things that are working under the hood
and we can't really be sure that the data we are working with is actually the data
that we want to work with. Due to the asynchronous and binding nature of using 
ngModule, the data that we are working with inside of our component might not be
what we need to work with. 

This leads us to Reactive Forms. We want to do this inside a new module so that we
can swap these modules as we need. So we create a module called contact and also a
component named contact inside of that module. Whenever we used the ngModule- 
directive, we had to include the FormsModule, but we don't do that with reactive
forms, instead we use ReactiveFormsModule. Now that we've done that we should put
ContactComponet in the exports array. Now we navigate to the Ap pModule and the App 
Component to be sure to import that ContactModule. 

Now we'll paste the markup for a form in our contact component which is a contact
form. Now we'll go to the component and we want to use reactive forms. The primary 
way to do that is importing a class called FormControl. What we do is create form
control and bind that to the individual fields in our form. We need to import this
from angular/forms, and then we are going to define our properties that are going
to represent those FormControl's. We have 3, the senderNameControl, where we want
to new up the FormControl constructor. Now we can initialize it with a value, and
here an empty string would be fine. We also have senderEmailControl, which again
we will new up the constructor for, and finally we have the senderMessageControl.

Now that we have these controls we need to bind them to the actual form fields.
We're going to do that inside of our template, we're going to add a directive 
called FormControl. The only difference between this approach and template-dirven,
is that we have created those properties explicitly as FormControl objects and we
are binding those objects to these form fields. 

A question that we may have is why use reactive forms since the setup is mostly the
same as template-driven. The key is we used the term objects, we created these
FormControl objects and as such, this gives us an API that we can tap into to make
our forms a lot more flexible. For example we're going to have a method called
submit form which we are going to create in contact component. But if we just take
a look at one of these like the senderEmailControl, and see what Intellisence is 
going to pop up, we se that there a lot of properties and methods. For example,
there is a dirty property, if this property is true, then the value in that form
field has changed from its original value. And that is valuable to know while we
process the form. There's also the pristine property which is simply the oposite.
If the value of this particular form control has not changed, then pristine is
going to be true. It also gives us the abilty to mark a form as pristine, there's
also a term called touched, meaning that the user has given focus to the form field 
and then took the focus away. There are also validators which are very useful.

After defining the submitForm function and used dirty on the name field, we go to
the template file and handle the click event, first we will prevent the default 
from happening, and then we can call the submitForm function.

In the previous section we created a contact form and used reactive forms to
set up the ability to process this form. We haven't done any processing, but
we also talked about the benefits of using reactive forms instead of template
driven, one is that we get this API which gives us a flexible way of processing
a form. It also gives us the sense of data integrity. Because as the user
submits the form, we get a snapshot of the data of that form at the time it 
was submitted. 

In this section we want to take this further and organize this form into groups,
because our form has just three form fields. These fields relate to each 
other so it makes sense to group them all together. To do that, we need to
import the FormGroup class and we'll create our group by creating another
property which we call contactForm and we will new up the FormGroup constructor.
This accepts an object which basically allows us to define our data model.
So just like we defined our model with individual properties, now we are
going to have a model that is encapsulated within this FormGroup. We can
now take the properties we created in the previous lesson and paste them 
inside of this form group. We also need to modify the syntax a bit.

To make them easier to deal with we remove the "control" from the property 
names. We'll comment the body for the submit function for now. Now we go to
the template file to bind our form to our form group. We are going to use a 
directive called formGroup and assign the contactForm that we created to it.
And for the individual fields we no longer use the formControl directive.
Instead we use an attribute called formControlName. And the value is the name
of the property in our form group. Now we need to change the formControl
directive to the formControlName.

So now we have the group and it is properly bound to our form. The other 
thing we want to change is getting rid of the click event on our button.
Because instead of listening for this event, we want to listen for the submit
event on this form, and we do that by binding to the ngSubmit event. The 
reason why we want to do this is because it allows the user to submit the 
form, both by clicking on a button that has a type of submit, which we have,
but it also lets the user use the Enter key on the keyboard. 

This gives us a different way of accessing the elements in our form, but
also just working with the form in general. When we submit the form with the
current formGroup and functionality, we see that we get an object with three
properties (name, email, message) and if we change any of the form field
values, we are going to see those values represented whenever the form is 
submitted. By using the form group, we also have the ability to check the 
validity of the entire form all at once. To do that we need to use the 
valid property. Since we haven't defined any validators, this is always
going to be true. But instead of checking each individual property, we check
to see if the form itself is valid.

JavaScript was created for the explicit purpose of processing forms. Before
we had JS, it was very frustrating. JavaScript made it so we could process
forms inside of the browser. Just a few years ago the validty API was 
introduced and it made it much easier to process forms. With Angular, it is
very easy to validate a form. We have to first import Validators from Forms.

We need to get the name and email from the user, otherwise what would be the
point of receiving a mesage from them. Whenever we create these form controls,
we can pass in a second argument, that is the validator we want to use. We
want all of those fields to be required so we pass the required validator to
each one of those controls.

We had that code that output the value of the valid property on our form.
And in the previous lesson, it returned true because we didn't have any
validators. But now whenever we submit an empty form, it returns false, because
all of our fields are required. If we provide some information and then 
submit the form, it is now true. We need to pass more validators, especially
for the email, since we need a syntactically correct email address. So we
can also pass an array of validators.

There'sa validator called email which we can use beside required. If the 
message is less than for example 10 characters, it wouldn't be logical; so
we can use the minLength validator for it and specify the minLength.

After applying these validators, if we submit the dorm without providing a
a name, a valid email, and a valid message, the validity of the form will
be false in the console. But we need to display something visual to tell the
user that they are submitting an invalid form.

One thing we can do is add a visual cue to the button, we can disable the
button if the form is not valid, so we can bind to the disabled property.
We can do this in a couple of different ways, we can use our contactForm 
object, we have the valid property which we have been working with, we could
say that this is disabled if not valid. This aspproach is not really logical. 
But it does work indeed. Instead we can use the invalid property. So if this
property is true, then the button would be disabled. 

But our validation still needs some work because we need to tell the user
what they need to provide. There are a bunch of ways we could do this but
what we want to do is add a message to the bottom of the field, to specify
the error that the user needs to fix. We're gonna add a div element after 
the input element, but we only want to show this div element if the email 
field is not valid. So we can use ngIf and we'll use our contactForm. But
that's not good enough because we want our individual email field. We can
use the get method on contactForm and pass in the name of the field that
we want to get. Then we can check if it is invalid. If we do this we'll get
and error and it says that the object is possibly null which seems like sth
is wrong here. What we can do is use the null coalescing operator, so what
we can use is essentially the null-checking operator. The operator for this
is a question mark followed by a dot. What it says is that if what comes 
before this operator is null, then it's fine, don't do anything. However
if it's not null, then it's going to go ahead and check the invalid property.
So if it is valid we can display that "this is invalid".

One problem is with this code, as the user sees the form this message is 
going to be displayed which is not ideal, we want the message to be hidden
until the user does something with this field. So if they give focus to it
and they decide to not put anything in, and move on to the next field, that 
would be the perfect time to display this error message. 

So we have added some code to our template and used ngIf to check if what the
user entered is invalid, and if the field is dirt or if it has been touched,
then we want to display the error message. So this approach does get verbose,
another thing we could do is create some kind of helper method, or a helper
property inside componet class so that we could get to this information a 
little bit easier. We're gonna leave it as is.

The error message for the email address needs to be specific and tell the
user what they actually need to do. We're going to modify the template and
use <small> elements here, we set the class to sext-danger so that it is
red, and then we're going to use ngIf to check what kind of error we are
encountering here. We're going to use an ngIf for the small element and
use the code for invalid input from before and use hasError instead of the
invalid property. Then we can pass in the name of the validator we want to
check for to hasError, so in this case we use the required validator. If 
that is the error, we can say that this field is required. 

So with these validators in place, when the user touches the email field
and moves on without typing anything in, the page is going to say this 
field is required, and if the input is not an email address, whey will see 
"Please enter your email address." We'll copy the code for the email field
and paste it for the message field, and of course instead of using 
senderEmail, this is senderMessage. For the minLength error, all we would 
use is the name of the validator. When we pass the name of the validator to
hasError, we should type the letters all in lower case.








